package com.apamax.functional;

/** @private */
event Util
{
	static action getFuncReturnType(any func) returns string
	{
		if func.hasAction("getFuncReturnType") {
			return (<action<> returns string> func.getAction("getFuncReturnType"))();
		}
		return func.getActionReturnTypeName();
	}

	static action getGenericAction(any func) returns action<sequence<any>> returns any
	{
		if func.hasAction("execGeneric") {
			return <action<sequence<any>> returns any> func.getAction("execGeneric");
		} else if func.hasAction("generate") {
			return func.getAction("generate").getGenericAction();
		}
		switch (func) {
			case action<sequence<any>> returns any: {
				return func;
			}
			default: {
				return func.getGenericAction();
			}
		}
	}
	
	static action getNumberOfArgs(any func) returns integer
	{
		if func.hasAction("getNumberOfArgs") {
			return (<action<> returns integer> func.getAction("getNumberOfArgs"))();
		}
		return func.getActionParameterTypeNames().size();
	}

	/** Convert value(s) of arg to a sequence<any> containing the value(s).
		If arg is not a sequence, create the sequence and put the value in it.
		If arg is already a sequence, copy the values from the sequence.
	*/ 
	static action getGenericSequence(any arg) returns sequence<any> {
		if arg.empty() {
			return new sequence<any>;
		} else if arg.getTypeName().find("sequence<") = 0 {	// already a sequence?
			return arg.getEntries();
		} else {
			return [arg];
		}
	}

	/** Return a new default instance of the return type of the function.
	 */
	static action returnTypeInstanceOf(any func) returns any {
		return any.newInstance(getFuncReturnType(func));
	}
}

/**
  Represents a generator over a function. This class is used internally by Functional, but you can use any event with a generate method.
  Generate methods must take 0 arguments and can return the type of your choice (or any).
 */
event Generator
{
	/** @private */
	static action create(any start, any func) returns Generator
	{
		Generator g := new Generator;
		g.accumulator := start;
		g.func := Util.getGenericAction(func);
		g.retType := Util.getFuncReturnType(func);
		g.args := [g.accumulator];
		return g;
	}
	
	/** @private */
	action getFuncReturnType() returns string { return retType; }

	/**
	  Returns the next item from this generator.
	  @returns The next item.
	*/
	action generate() returns any
	{
		args[0] := accumulator;
		accumulator := func(args);
		return accumulator;
	}

	/** @private */
	any accumulator;
	/** @private */
	action<sequence<any>> returns any func;
	/** @private */
	sequence<any> args;
	/** @private */
	string retType;
}

/** @private */
event GenerateIf
{
	static action create(action<sequence<any>> returns any wrapped, action<sequence<any>> returns any predicate, string retType) returns GenerateIf
	{
		GenerateIf gi := new GenerateIf;
		gi.wrapped := wrapped;
		gi.predicate := predicate;
		gi.wrappedargs := new sequence<any>;
		gi.args := [new any];
		gi.retType := retType;
		return gi;
	}
	action generate(any _) returns any
	{
		while true {
			any candidate := wrapped(wrappedargs);
			args[0] := candidate;
			if <boolean> predicate(args) {
				return candidate;
			}
		}
		return new any; // never happens
	}
	action getFuncReturnType() returns string { return retType; }
	action<sequence<any>> returns any wrapped;
	action<sequence<any>> returns any predicate;
	sequence<any> wrappedargs;
	sequence<any> args;
	string retType;
}
/** @private */
event GenerateWrap
{
	static action create(action<sequence<any>> returns any wrapped, action<sequence<any>> returns any func, string retType) returns GenerateWrap
	{
		GenerateWrap gw := new GenerateWrap;
		gw.wrapped := wrapped;
		gw.func := func;
		gw.wrappedargs := new sequence<any>;
		gw.args := [new any];
		gw.retType := retType;
		return gw;
	}
	action generate(any _) returns any
	{
		args[0] := wrapped(wrappedargs);
		return func(args);
	}
	action getFuncReturnType() returns string { return retType; }
	action<sequence<any>> returns any wrapped;
	action<sequence<any>> returns any func;
	sequence<any> wrappedargs;
	sequence<any> args;
	string retType;
}

/** @private */
event AccumulateGenerator
{
	static action create(any container, any func) returns AccumulateGenerator
	{
		return createFrom(Util.returnTypeInstanceOf(func), container, func);
	}

	static action createFrom(any start, any container, any func) returns AccumulateGenerator
	{
		AccumulateGenerator ag := new AccumulateGenerator;
		ag.container := container;
		ag.func := Util.getGenericAction(func);
		ag.acc := start;
		ag.retType := Util.getFuncReturnType(func);

		string tn := container.getTypeName();
		if tn.find("sequence<") = 0 {
			ag.index := 0;
		} else if container.hasAction("generate") {
			/*action<sequence<any>> returns any act := container.getAction("generate").getGenericAction();
			any foo := <action<sequence<any>> returns any> act;
			foo := <action<sequence<any>> returns any> ag.index;*/
			ag.index := container.getAction("generate");
		} else {
			throw com.apama.exceptions.Exception("Can only accumulate over sequence or generator types", "typeException");
		}
		ag.args := [new any, new any];
		return ag;
	}
	action generate(any _) returns any
	{
		any value := new any;
		switch(index) {
			/*case action<sequence<any>> returns any: {
				// it's a generator
				value := index(args);
			}*/
			case integer: {
				// it's a sequence
				if not container.hasEntry(index) { return new any; }
				value := container.getEntry(index);
				self.index := index + 1;
			}
			default: {
				value := index.getGenericAction()(new sequence<any>);
			}
		}
		args[0] := acc;
		args[1] := value;
		acc := func(args);
		return acc;
	}
	action getFuncReturnType() returns string { return retType; }
	any container;
	action<sequence<any>> returns any func;
	sequence<any> args;
	any acc;
	any index;
	string retType;
}

/** @private */
event ArgMapGenerator
{
	static action create(action<sequence<any>> returns any source, any func) returns ArgMapGenerator
	{
		ArgMapGenerator ag := new ArgMapGenerator;
		ag.func := Util.getGenericAction(func);
		ag.retType := Util.getFuncReturnType(func);
		ag.source := source;
		ag.args := new sequence<any>;
		return ag;
	}
	action generate(any _) returns any
	{
		any args := source(self.args);
		return func(args.getEntries());
	}
	action getFuncReturnType() returns string { return retType; }
	action<sequence<any>> returns any func;
	action<sequence<any>> returns any source;
	sequence<any> args;
	string retType;
}

/** @private */
event SequenceCycleGenerator
{
	static action create(any seq) returns SequenceCycleGenerator
	{
		SequenceCycleGenerator sg := new SequenceCycleGenerator;
		sg.seq := seq;
		sg.seqsize := (<action<> returns integer> seq.getAction("size"))();
		sg.index := 0;
		sg.retType := seq.getTypeName().substring(9,-1);
		return sg;
	}
	action generate(any _) returns any
	{
		any value := seq.getEntry(index);
		index := index + 1;
		if index >= seqsize { index := 0; }
		return value;
	}
	action getFuncReturnType() returns string { return retType; }
	any seq;
	integer index;
	integer seqsize;
	string retType;
}

/** @private */
event NotPred
{
	action<sequence<any>> returns any pred;
	sequence<any> args;
	action execute(any i) returns boolean
	{
		args[0] := i;
		return not <boolean> pred(args);
	}
}

/** A partially evaluated function which can be passed to functional operators or later executed with the remaining arguments.

	eg: <tt>Partial p := Fn.partial(concatFn, "Hello"); &lt;string&gt;p.exec(" world");</tt>
*/
event Partial
{
	/** @private */
	static action create(any arguments, any func) returns Partial
	{
		Partial p := new Partial;
		p.args := Util.getGenericSequence(arguments);
		p.curriedArgs := p.args.size();
		p.func := Util.getGenericAction(func);
		p.retType := Util.getFuncReturnType(func);
		p.nArgs := Util.getNumberOfArgs(func)-p.args.size();
		return p;
	}
	action getNumberOfArgs() returns integer { return nArgs; }
	/** @private */
	action getFuncReturnType() returns string { return retType; }
	/** @private */
	action execGeneric(sequence<any> args) returns any { return exec(args); }
	/** 
		Execute the underlying function, passing in the remaining arguments.
		@param args The remaining single argument, or sequence of all remaining arguments.
		@return The result of executing the underlying function with the original and remaining arguments.
	*/
	action exec(any args) returns any
	{
		sequence<any> _args;
		if args.empty() { _args := new sequence<any>; }
		else { _args := args.getEntries(); }
		integer targetArgs := curriedArgs+_args.size();
		if (self.args.size() != targetArgs) {
			self.args.setSize(targetArgs);
		}
		integer i := curriedArgs;
		any a;
		for a in _args {
			self.args[i] := a;
			i := i + 1;
		}
		
		return func(self.args);
	}
	/** 
		Add more partial arguments and return a new Partial which wraps this one.
		@param args The additional single argument, or sequence of several additional arguments.
	*/
	action partial(any arguments) returns Partial
	{
		return Partial.create(arguments, self);
	}
	/** @private */
	sequence<any> args;
	/** @private */
	integer curriedArgs;
	/** @private */
	action<sequence<any>> returns any func;
	/** @private */
	string retType;	
	/** @private */
	integer nArgs;
}

/**

Provides functional operations on EPL containers, such as map, reduce, filter and slice.

Also provides generators which can be used as input to the functional operations.

eg: <tt>Fn.slice(Fn.map(Fn.filter(Fn.count(), (integer i)->i%2=0), (integer i)->i*2), 2, 8, 2);</tt>
*/
event Fn
{
	/**
	  Takes either a sequence, a dictionary or a generator and filters the contents using a boolean predicate func.

	  eg: <tt>Fn.filter(numbers, (integer i)->i%2=0)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPE&gt; container</tt> and <tt>action&lt;TYPE&gt; returns boolean func</tt> will return <tt>sequence&lt;TYPE&gt;</tt> containing all the elements for which <tt>func</tt> returned true.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPE&gt; container</tt> and <tt>action&lt;KEYTYPE,VALUETYPE&gt; returns boolean func</tt> will return <tt>dictionary&lt;KEYTYPE,VALUETYPE&gt;</tt> containing all the elements for which <tt>func</tt> returned true.</li>
	  	<li>A generator returning <tt>TYPE</tt> and <tt>action&lt;TYPE&gt; returns boolean func</tt> will return a generator returning <tt>TYPE</tt> which only generates items from the original generator for which <tt>func</tt> returned true.</li>
	  </ul>
	  @param container A sequence, dictionary or generator.
	  @param func A boolean predicate function or lambda.
	  @returns The container filtered using the predicate function.
	*/
	static action filter(any container, any func) returns any
	{
		string tn := container.getTypeName();
		any newcontainer := new any;
		action<sequence<any>> returns any genericFunc := Util.getGenericAction(func);
		if tn.find("sequence<") = 0 {
			newcontainer := any.newInstance(tn);
			action<integer> setsize := <action<integer>> newcontainer.getAction("setSize");
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			setsize(getsize());
			any value := new any;
			integer index := 0;
			sequence<any> args := [value];
			for value in container.getEntries() {
				args[0] := value;
				if <boolean> genericFunc(args) {
					newcontainer.setEntry(index, value);
					index := index + 1;
				}
			}
			setsize(index);
		} else if tn.find("dictionary<") = 0 {
			newcontainer := any.newInstance(tn);
			integer nArgs := Util.getNumberOfArgs(func);
			any key := new any;
			sequence<any> args := [key];
			for key in container.getKeys() {
				any value := container.getEntry(key);
				if (nArgs = 1) {
					args[0] := value;
				} else {
					args.setSize(2);
					args[0] := key;
					args[1] := value;
				}
				if <boolean> genericFunc(args) {
					newcontainer.setEntry(key, value);
				}
			}
		} else if container.hasAction("generate") {
			newcontainer := Generator.create(new any, GenerateIf.create(container.getAction("generate").getGenericAction(), genericFunc, Util.getFuncReturnType(container.getAction("generate"))));
		} else {
			throw com.apama.exceptions.Exception("Can only filter over container or generator types", "typeException");
		}
		return newcontainer;
	}

	/**
	  Takes either a sequence, a dictionary or a generator and maps the contents using a function.

	  eg: <tt>Fn.map(numbers, (integer i)->i*2)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPEA&gt; container</tt> and <tt>action&lt;TYPEA&gt; returns TYPEB func</tt> will return <tt>sequence&lt;TYPEB&gt;</tt> containing the result of running <tt>func</tt> on all the elements in <tt>container</tt>.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPEA&gt; container</tt> and <tt>action&lt;KEYTYPE,VALUETYPEA&gt; returns VALUETYPEB func</tt> will return <tt>dictionary&lt;KEYTYPE,VALUETYPEB&gt;</tt> containing the keys from <tt>container</tt> with the values being the result of running <tt>func</tt>.</li>
	  	<li>A generator returning <tt>TYPEA</tt> and <tt>action&lt;TYPEA&gt; returns TYPEB func</tt> will return a generator returning <tt>TYPEB</tt> where each item is the corresponding item from the original generator after running <tt>func</tt>.</li>
	  </ul>
	  @param container A sequence, dictionary or generator.
	  @param func A function or lambda from old value type to new value type.
	  @returns The container with all the values run through func.
	*/
	static action map(any container, any func) returns any
	{
		string tn := container.getTypeName();
		any newcontainer := new any;
		action<sequence<any>> returns any genericFunc := Util.getGenericAction(func);
		if tn.find("sequence<") = 0 {
			newcontainer := any.newInstance("sequence<"+Util.getFuncReturnType(func)+">");
			action<integer> setsize := <action<integer>> newcontainer.getAction("setSize");
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			setsize(getsize());
			any value := new any;
			integer index := 0;
			sequence<any> args := [value];
			for value in container.getEntries() {
				args[0] := value;
				newcontainer.setEntry(index, genericFunc(args));
				index := index + 1;
			}
		} else if tn.find("dictionary<") = 0 {
			integer nArgs := Util.getNumberOfArgs(func);
			newcontainer := any.newInstance("dictionary<"+container.getAction("hasKey").getActionParameterTypeNames()[0]+","+Util.getFuncReturnType(func)+">");
			any key := new any;
			sequence<any> args := [key];
			for key in container.getKeys() {
				any value := container.getEntry(key);
				if (nArgs = 1) {
					args[0] := value;
				} else {
					args.setSize(2);
					args[0] := key;
					args[1] := value;
				}
				newcontainer.setEntry(key, genericFunc(args));
			}
		} else if container.hasAction("generate") {
			newcontainer := Generator.create(new any, GenerateWrap.create(container.getAction("generate").getGenericAction(), genericFunc, Util.getFuncReturnType(container.getAction("generate"))));
		} else {
			throw com.apama.exceptions.Exception("Can only map over container or generator types", "typeException");
		}
		return newcontainer;
	}

	/**
	  Takes either a sequence or a dictionary and accumulates all of the values using an accumulator function, returning the final result.

	  eg: <tt>Fn.reduce(numbers, (integer a, integer i)->a+i)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPEA&gt; container</tt> and <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB func</tt> will return the final <tt>TYPEB</tt> after calling <tt>func</tt> on each value, retaining <tt>TYPEB</tt> each time.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPE&gt; container</tt> and <tt>action&lt;TYPEB,KEYTYPE,VALUETYPE&gt; returns TYPEB func</tt> will return the final <tt>TYPEB</tt> after calling <tt>func</tt> on each key and value, retaining <tt>TYPEB</tt> each time.</li>
	  </ul>
	  @param container A sequence or dictionary.
	  @param func An accumulator function or lambda.
	  @returns The final result of the accumulator function.
	*/
	static action reduce(any container, any func) returns any
	{
		return reduceFrom(Util.returnTypeInstanceOf(func), container, func);
	}
	
	/**
	  Takes either a sequence or a dictionary and accumulates all of the values using an accumulator function, returning the final result.

	  eg: <tt>Fn.reduceFrom(42, numbers, (integer a, integer i)->a+i)</tt>

	  Specifically, given:
	  <ul>
	  	<li><tt>sequence&lt;TYPEA&gt; container</tt> and <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB func</tt> will return the final <tt>TYPEB</tt> after calling <tt>func</tt> on each value, retaining <tt>TYPEB</tt> each time.</li>
	  	<li><tt>dictionary&lt;KEYTYPE,VALUETYPE&gt; container</tt> and <tt>action&lt;TYPEB,KEYTYPE,VALUETYPE&gt; returns TYPEB func</tt> will return the final <tt>TYPEB</tt> after calling <tt>func</tt> on each key and value, retaining <tt>TYPEB</tt> each time.</li>
	  </ul>
	  @param accumulator initial value, of <tt>TYPEB</tt>
	  @param container A sequence or dictionary.
	  @param func An accumulator function or lambda.
	  @returns The final result of the accumulator function.
	*/
	static action reduceFrom(any accumulator, any container, any func) returns any
	{
		string tn := container.getTypeName();
		action<sequence<any>> returns any genericFunc := Util.getGenericAction(func);
		if tn.find("sequence<") = 0 {
			any value := new any;
			sequence<any> args := [accumulator, value];
			for value in container.getEntries() {
				args[0] := accumulator;
				args[1] := value;
				accumulator := genericFunc(args);
			}
		} else if tn.find("dictionary<") = 0 {
			integer nArgs := Util.getNumberOfArgs(func);
			any key := new any;
			sequence<any> args := [accumulator, key];
			sequence<any> keys := container.getKeys();
			keys.sort();
			for key in keys {
				any value := container.getEntry(key);
				if nArgs = 3 {
					args.setSize(3);
					args[0] := accumulator;
					args[1] := key;
					args[2] := value;
				} else {
					args[0] := accumulator;
					args[1] := value;
				}
				accumulator := genericFunc(args);
			}
		} else {
			throw com.apama.exceptions.Exception("Can only reduce over container or generator types", "typeException");
		}
		return accumulator;
	}

	/**
	  Takes either a sequence or a generator and returns a given sub-range as a finite sequence. If it is passed a generator, it will invoke the generator sufficient times immediately to satisfy the slice.

	  eg: <tt>Fn.slice(numbers, 5, 20, 2)</tt>

	  @param container A <tt>sequence&lt;TYPE&gt;</tt> or generator which produces <tt>TYPE</tt>.
	  @param start The first item to return.
	  @param end The last item to return (-1 = all, only permitted for sequences).
	  @param stride The number of items to increment each time (1 = all).
	  @returns A <tt>sequence&lt;TYPE&gt;</tt> containing the selected values from <tt>container</tt>
	*/
	static action slice(any container, integer start, integer end, integer stride) returns any
	{
		if start < 0 { throw com.apama.exceptions.Exception("Cannot start a slice at a negative number", "argumentException"); }
		if stride < 1 { throw com.apama.exceptions.Exception("Slice stride must be at least 1", "argumentException"); }

		string tn := container.getTypeName();
		any slice := new any;
		if tn.find("sequence<") = 0 {
			slice := any.newInstance(tn);
			action<> returns integer getsize := <action<> returns integer> container.getAction("size");
			integer size := getsize();
			action<sequence<any>> returns any append := slice.getAction("append").getGenericAction();
			sequence<any> args := [new any];
			integer i := start;
			end := integer.min(end, size);
			if end < 0 { end := size; }
			while i < end {
				args[0] := container.getEntry(i);
				any _ := append(args);
				i := i + stride;
			}
		} else if container.hasAction("generate") {
			if end < 0 { throw com.apama.exceptions.Exception("Cannot end a slice of a generator at a negative number", "argumentException"); }
			action<> returns any generate := <action<> returns any> container.getAction("generate");
			any value := generate();
			if slice.empty() {
				slice := any.newInstance("sequence<"+value.getTypeName()+">");
			}
			action<sequence<any>> returns any append := slice.getAction("append").getGenericAction();
			sequence<any> args := [new any];
			integer i := 0;
			while i < start { value := generate(); i := i + 1; }
			while i < end {
				args[0] := value;
				any _ := append(args);
				integer j := 0;
				while j < stride { value := generate(); i := i + 1; j := j + 1; }
			}
		} else {
			throw com.apama.exceptions.Exception("Can only slice sequence or generator", "typeException");
		}
		return slice;
	}
	/**
	  Create a generator from a function, which is passed the previous value and should return the next value.
	  The initial value will be a default-initialized <tt>TYPE</tt> and the result of first generation will be the result of invoking <tt>func</tt> on that default-initialized value. To specify the initial value, use generateFrom.

	  eg: <tt>Fn.generator((integer i)->i+1)</tt>

	  @param func An <tt>action&lt;TYPE&gt; returns TYPE</tt> action or lambda which takes the previous value and returns the next value.
	  @returns A generator for <tt>TYPE</tt>.
	*/
	static action generator(any func) returns Generator
	{
		return Generator.create(Util.returnTypeInstanceOf(func), func);
	}
	/**
	  Create a generator from a function, which is passed the previous value and should return the next value.

	  eg: <tt>Fn.generatorFrom(100, (integer i)->i+1)</tt>

	  @param start The value to pass to func to generate the first generation.
	  @param func An <tt>action&lt;TYPE&gt; returns TYPE</tt> action or lambda which takes the previous value and returns the next value.
	  @returns A generator for <tt>TYPE</tt>.
	*/
	static action generatorFrom(any start, any func) returns Generator
	{
		return Generator.create(start, func);
	}

	/** 
		Increments the given integer
	*/
	static action increment(integer i) returns integer { return i+1; }
	/**
	  Returns a generator producing sequential integers with the first one being 0.
	*/
	static action count() returns Generator
	{
		return generatorFrom(-1, increment/* (integer i) -> i+1 */);
	}

	/**
	  Returns a range of integers from <tt>start</tt> (inclusive) to <tt>end</tt> (exclusive), incrementing <tt>stride</tt> each time.
	*/
	static action range(integer start, integer end, integer stride) returns sequence<integer>
	{
		// better would be slice(generatorFrom(start-1, (integer i)->i+stride), 0, (end-start)/stride, 1)
		return <sequence<integer>> slice(generatorFrom(start-1, increment), 0, end-start, stride);
	}

	/** @private */
	static action identity(any a) returns any { return a; }
	/**
	  Repeats the given element forever.
	  @param item The item to return.
	  @returns A generator which returns item over and over again.
	*/
	static action repeat(any item) returns Generator
	{
		return generatorFrom(item, identity/* (any a)->a */);
	}
	/** Iterates through a sequence of items and continues looping forever.
	  @param seq The sequence of values to iterate over
	  @returns A generator which iterates over <tt>seq</tt>
	*/
	static action cycle(any seq) returns Generator
	{
		return generator(SequenceCycleGenerator.create(seq).generate);
	}
	/** Iterates through a sequence, or a generator and uses the result as a list of arguments with which to invoke a function.
		These inner sequences will be treated as a list of arguments to the given function, or a single argument to that function.
		Each generated item will be the result of calling func with the next set of arguments.
		@param container A sequence or a generator.
		@param func A function which takes each item in container and returns a result.
	*/
	static action argmap(any container, any func) returns Generator
	{
		action<sequence<any>> returns any source;
		if container.hasAction("generate") {
			source := container.getAction("generate").getGenericAction();
		} else if container.getTypeName().find("sequence<") = 0 {
			source := (<any>cycle(container).generate).getGenericAction();
		} else {
			throw com.apama.exceptions.Exception("Can only argmap over a sequence or generator", "typeException");
		}
		return generator(ArgMapGenerator.create(source, func).generate);
	}
	/**
	  Returns a sequence containing the given item the given number of times.
	  @param item The element to put in the sequence.
	  @param n The number of times to repeat the element.
	  @returns A <tt>sequence&lt;ITEMTYPE&gt;</tt> with <tt>n</tt> <tt>item</tt>s in it.
	*/
	static action sequenceOf(any item, integer n) returns any
	{
		return slice(repeat(item), 0, n, 1);
	}

	/**
	  Returns a generator which accumulates over the underlying container, returning the result after accumulating each item.
	  Similar to reduce, but returns a generator for each item in turn, rather than just the final total.
	  The initial value of the accumulator is the default value of func's return type (<tt>TYPEB</tt>).
	  @param container The sequence, dictionary or generator to accumulate.
	  @param func An <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB</tt> action or lambda which accumulates each item in turn and returns the new total.
	  @returns A generator which returns each accumulated item in turn.
	  @see reduce
	*/
	static action accumulate(any container, any func) returns Generator
	{
		return accumulateFrom(Util.returnTypeInstanceOf(func), container, func);
	}
	/**
	  Returns a generator which accumulates over the underlying container, returning the result after accumulating each item.
	  Similar to reduce, but returns a generator for each item in turn, rather than just the final total.
	  @param start The initial value of the accumulator; must have the same type as func's return type (<tt>TYPEB</tt>).
	  @param container The sequence, dictionary or generator to accumulate.
	  @param func An <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB</tt> action or lambda which accumulates each item in turn and returns the new total.
	  @returns A generator which returns each accumulated item in turn.
	  @see reduceFrom
	*/
	static action accumulateFrom(any start, any container, any func) returns Generator
	{
		return Generator.create(new any, AccumulateGenerator.createFrom(start, container, func).generate);
	}
	/**
	  Action for adding up a sequence or generator of integer, float or decimal using accumulate or reduce.

	  eg: <tt>integer sum := Fn.reduce(numbers, Fn.sum);</tt>
	*/
	static action sum(any acc, any i) returns any
	{
		switch (i) {
			case integer: {
				if acc.empty() { acc := 0; }
				return i+<integer> acc;
			}
			case float: {
				if acc.empty() { acc := 0.; }
				return i+<float> acc;
			}
			case decimal: {
				if acc.empty() { acc := 0.d; }
				return i+<decimal> acc;
			}
		}
	}
	/**
	  Action for multiplying together the values in a sequence or generator of integer, float or decimal using accumulate or reduce.

	  eg: <tt>integer product := Fn.reduce(numbers, Fn.mul);</tt>
	*/
	static action mul(any acc, any i) returns any
	{
		switch (i) {
			case integer: {
				if acc.empty() { acc := 1; }
				return i*<integer> acc;
			}
			case float: {
				if acc.empty() { acc := 1.; }
				return i*<float> acc;
			}
			case decimal: {
				if acc.empty() { acc := 1.d; }
				return i*<decimal> acc;
			}
		}
	}
	/**
		Action which concatenates strings using accumulate or reduce.
	*/
	static action concat(string acc, string i) returns string
	{
		return acc+i;
	}
	/**
		A predicate which returns true if the argument is even.
	*/
	static action even(integer i) returns boolean
	{
		return i%2=0;
	}
	/**
		A predicate which returns true if the argument is odd.
	*/
	static action odd(integer i) returns boolean
	{
		return i%2=1;
	}
	/** A predicate which returns true if the argument is a whole number. */
	static action whole(any i) returns boolean
	{
		switch (i) {
			case integer: { return true; }
			case float: { return i.fractionalPart() = 0.; }
			case decimal: { return i.fractionalPart() = 0.d; }
		}
	}
	/** A predicate which returns true if the argument is positive (not including 0). */
	static action positive(any i) returns boolean
	{
		switch (i) {
			case integer: { return i > 0; }
			case float: { return i > 0.; }
			case decimal: { return i > 0.d; }
		}
	}
	/** A predicate which returns true if the argument is negative. */
	static action negative(any i) returns boolean
	{
		switch (i) {
			case integer: { return i < 0; }
			case float: { return i < 0.; }
			case decimal: { return i < 0.d; }
		}
	}
	/** A predicate which inverts the value of another predicate. */
	static action _not(any pred) returns action<any> returns boolean
	{
		return NotPred(pred.getGenericAction(), [new any]).execute;
	}
	/** Partially execute a function, providing some arguments, to be later executed with the remaining arguments.
	  Arguments must be provided left-to-right for the function call to be invoked.
      eg: <tt>Partial p := Fn.partial(concatFn, "Hello"); &lt;string&gt;p.exec(" world");</tt>
	  Partial objects can be passed to any of the other actions on Fn where an action would be expected.
	  @param args The arguments to store for later execution. May be a single argument, or a sequence of several arguments.
	  @param func A function (including an earlier partial()) to execute once all arguments are provided.
	*/
	static action partial(any func, any args) returns Partial
	{
		return Partial.create(args, func);
	}
	
	/** TODO - run func on pair-wise elements of two iterables 
	static action zipfn(any containerA, any containerB, any func) returns Generator {} */
	/** TODO - take any number of arguments and return them in a sequence
	static action combine(sequence<any> args) returns any {} */
	/** TODO - zipfn with combine as the fn
	static action zip(any containerA, any containerB) returns Generator {} */
	/** TODO - consume n records from generator, returning it
	static action consume(any generator, integer n) returns any {} */
	/** TODO - counts the number of times a predicate is true
	static action quantify(any container, any pred) returns integer {} */
	/** TODO - concatenates two sequences
	static action concatseq(any seqA, any seqB) returns any {} */
	/** TODO - pads sequence with n instances of value
	static action padseq(any seq, any item, integer n) returns any {} */
	/** A predicate which returns true if the argument is true. */
	static action istrue(boolean b) returns boolean { return b; }
	/** @private
		Functor used to implement _all()  */
	static action anyfalse(boolean acc, boolean b) returns boolean { 
		return acc or not b; 
	}

	/** @private
		Functor used to implement _any()*/
	static action anytrue(boolean acc, boolean b) returns boolean {
		return acc or b;
	}

	/**
		Logical 'AND' over a sequence of booleans
		@param seq sequence<any> of booleans.
		Return true iff none of the items in the sequence are false.  If seq is empty, returns true.
	 */
	static action _all(any seq) returns boolean { return not <boolean> reduceFrom(false, seq, anyfalse); } 

	/**
		Logical 'OR' over a sequence of booleans
		@param seq sequence<any> of booleans.
		Return false iff none of the items in the sequence are true.  If seq is empty, returns false.
	 */
	static action _any(any seq) returns boolean { return <boolean> reduceFrom(false, seq, anytrue); }
}

/**
  Wrapper event for usage of Fn in a fluent style. 
  Contains instance methods for operators, static methods for creation,
  all of which return values wrapped in a Functional for further calls.
  Functors and predicates are still used from Fn.
  The underlying value can be retrieved at the end of the chain with the <tt>get</tt> action.

  eg: <tt>Functional.count().filter(Fn.even)).map((integer i)->i*2).slice(2, 8, 2);</tt>

  You can create a Functional either using one of the static methods, 
  or by wrapping a sequence, dictionary or generator directly.

  eg: <tt>Functional([1,2,3,4]).filter(Fn.even).reduce(Fn.sum)</tt>
*/
event Functional
{
	/** Filters the contents using a boolean predicate func.
	
      Works on dictionary, sequence or generator.

	  eg: <tt>numbers.filter((integer i)->i%2=0)</tt>

	  Semantics are as <tt>Fn.filter</tt>
	  @param func A boolean predicate function or lambda.
	  @returns A Functional container filtered using the predicate function.
	  @see Fn.filter
	*/
	action filter(any func) returns Functional
	{ return Functional(Fn.filter(container, func)); }
	
	/**
	  Returns a given sub-range as a finite sequence. 
	
	  Works on sequence or generator. 
	  If it is a generator, it will invoke the generator sufficient times immediately to satisfy the slice.

	  eg: <tt>numbers.slice(5, 20, 2)</tt>

	  @param start The first item to return.
	  @param end The last item to return (-1 = all, only permitted for sequences).
	  @param stride The number of items to increment each time (1 = all).
	  @returns A Functional containing the selected range of values.
	  @see Fn.slice
	*/
	action slice(integer start, integer end, integer stride) returns Functional
	{ return Functional(Fn.slice(container, start, end, stride)); }
	
	/**
	  Maps the contents using a function.
	  
	  Works on dictionary, sequence or generator.
	
	  eg: <tt>numbers.map((integer i)->i*2)</tt>

	  Semantics are as <tt>Fn.map</tt>
	  
	  @param func A function or lambda from old value type to new value type.
	  @returns The container with all the values run through func.
	  @see Fn.map
	*/
	action map(any func) returns Functional
	{ return Functional(Fn.map(container, func)); }
	
	/**
	  Accumulates all of the contents using an accumulator function, returning the final result.

	  Works on a sequence or a dictionary. The result is the actual value, not a Functional, since it's no longer a container.
	
	  eg: <tt>numbers.reduce((integer a, integer i)->a+i)</tt>

	  Semantics are as <tt>Fn.reduce</tt>
	
	  @param func An accumulator function or lambda.
	  @returns The final result of the accumulator function.
	  @see Fn.reduce
	*/
	action reduce(any func) returns any
	{ return Fn.reduce(container, func); }
	
	/** 
	  Use the contents as a list of arguments with which to invoke a function.
	
	  Works on a sequence or a generator.
	
	  These inner sequences will be treated as a list of arguments to the given function, or a single argument to that function.
	  Each item in the result will be the result of calling func with the next set of arguments.
	  
	  @param func A function which takes each item in container and returns a result.
	  @see Fn.argmap
    */
	action argmap(any func) returns Functional
	{ return Functional(Fn.argmap(container, func)); }
	
	/**
	  Returns a generator which accumulates over the underlying container, returning the result after accumulating each item.
	  Similar to reduce, but returns a generator for each item in turn, rather than just the final total.
	  @param func An <tt>action&lt;TYPEB,TYPEA&gt; returns TYPEB</tt> action or lambda which accumulates each item in turn and returns the new total.
	  @returns A generator which returns each accumulated item in turn, wrapped in a Functional.
	  @see Fn.accumulate
	*/
	action accumulate(any func) returns Functional
	{ return Functional(Fn.accumulate(container, func)); }
	
	/**
	  If this Functional is wrapping a generator, generate one item with the underlying generator and return it.
	
	  Only works on generators.
	
	  @returns The next item from the wrapped generator.
	  @see Generator.generate
	*/
	action generate() returns any { return Util.getGenericAction(container.getAction("generate"))(new sequence<any>); }
	
	/**
	  Return the wrapped container.
    */
	action get() returns any { return container; }
	
	/**
	  Create a generator from a function, which is passed the previous value and should return the next value.
	  The initial value will be a default-initialized <tt>TYPE</tt> and the result of first generation will be the result of invoking <tt>func</tt> on that default-initialized value. To specify the initial value, use generateFrom.

	  eg: <tt>Functional.generator((integer i)->i+1)</tt>

	  @param func An <tt>action&lt;TYPE&gt; returns TYPE</tt> action or lambda which takes the previous value and returns the next value.
	  @returns A generator for <tt>TYPE</tt>, wrapped in a Functional.
	  @see Fn.generator
	*/
	static action generator(any func) returns Functional
	{ return Functional(Fn.generator(func)); }
	
	/**
	  Create a generator from a function, which is passed the previous value and should return the next value.

	  eg: <tt>Functional.generatorFrom(100, (integer i)->i+1)</tt>

	  @param start The value to pass to func to generate the first generation.
	  @param func An <tt>action&lt;TYPE&gt; returns TYPE</tt> action or lambda which takes the previous value and returns the next value.
	  @returns A generator for <tt>TYPE</tt>, wrapped in a functional.
	  @see Fn.generator
	*/
	static action generatorFrom(any start, any func) returns Functional
	{ return Functional(Fn.generatorFrom(start, func)); }
	
	/**
	  Returns a Functional generator producing sequential integers with the first one being 0.
	  @see Fn.count
	*/
	static action count() returns Functional
	{ return Functional(Fn.count()); }
	
	/**
	  Returns a Functional range of integers from <tt>start</tt> (inclusive) to <tt>end</tt> (exclusive), incrementing <tt>stride</tt> each time.
	  @see Fn.range
	*/
	static action range(integer start, integer end, integer stride) returns Functional
	{ return Functional(Fn.range(start, end, stride)); }
	
	/**
	  Repeats the given element forever.
	  @param item The item to return.
	  @returns A generator which returns item over and over again, wrapped in a Functional.
	  @see Fn.repeat
	*/
	static action repeat(any item) returns Functional
	{ return Functional(Fn.repeat(item)); }
	
	/** Iterates through a sequence of items and continues looping forever.
	  @param seq The sequence of values to iterate over
	  @returns A generator which iterates over <tt>seq</tt>, wrapped in a Functional
	  @see Fn.cycle
	*/
	static action cycle(any seq) returns Functional
	{ return Functional(Fn.cycle(seq)); }
	
	/**
	  Returns a sequence containing the given item the given number of times.
	  @param item The element to put in the sequence.
	  @param n The number of times to repeat the element.
	  @returns A <tt>sequence&lt;ITEMTYPE&gt;</tt> with <tt>n</tt> <tt>item</tt>s in it, wrapped in a Functional.
	  @see Fn.sequenceOf
	*/
	static action sequenceOf(any item, integer n) returns Functional
	{ return Functional(Fn.sequenceOf(item, n)); }
	
	/** @private */
	any container;
}
